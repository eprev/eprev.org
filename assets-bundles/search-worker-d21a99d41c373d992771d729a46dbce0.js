(function(){"use strict";self.addEventListener("message",(e=>{const{type:type}=e.data;if(type==="init"){getIndex().then((v=>self.postMessage({type:"ready"}))).catch((err=>self.postMessage({type:"error",err:err})))}else if(type==="search"){search(e.data.query).then((results=>self.postMessage({type:"results",results:results})))}}));const storage=function(){const store=new Promise(((resolve,reject)=>{const req=indexedDB.open("idb-storage",1);req.onerror=()=>reject(req.error);req.onsuccess=()=>resolve(req.result);req.onupgradeneeded=()=>req.result.createObjectStore("objects")}));function begin(mode,callback){return store.then((db=>new Promise(((resolve,reject)=>{let retVal;const transaction=db.transaction("objects",mode);transaction.oncomplete=()=>resolve(retVal);transaction.onabort=transaction.onerror=()=>reject(transaction.error);retVal=callback(transaction.objectStore("objects"))}))))}function get(key){return begin("readonly",(store=>store.get(key))).then((req=>req.result))}function set(key,value){return begin("readwrite",(store=>{store.put(value,key)}))}return{get:get,set:set}}();async function getIndex(){if(getIndex.index){return getIndex.index}else{let index=await storage.get("search-index");if(index){buildIndex().then((()=>self.postMessage({type:"updated"})))}else{index=await buildIndex()}return getIndex.index=index}}getIndex.index=undefined;const INDEX_NRGAM_SIZE=3;function ngram(text,size=2){const seq=[];text="-"+text.padEnd(size-2,"-")+"-";for(let i=0;i<text.length-size+1;++i){seq.push(text.slice(i,i+size))}return seq}function countItems(items,acc={},inc=1){return items.reduce(((acc,item)=>{acc[item]=acc[item]?acc[item]+inc:inc;return acc}),acc)}async function buildIndex(){const response=await fetch("/index.json");if(response.ok){const documents=await response.json();documents.forEach((doc=>{doc.tokens=Object.keys(doc.tokens).reduce(((ngrams,tk)=>{const freq=doc.tokens[tk];const seq=ngram(tk,INDEX_NRGAM_SIZE);return countItems(seq,ngrams,freq)}),{})}));const tokens=documents.reduce(((tokens,doc)=>countItems(Object.keys(doc.tokens),tokens)),{});const n=documents.length;const idf=Object.keys(tokens).reduce(((idf,tk)=>{idf[tk]=Math.log(n/tokens[tk]);return idf}),{});documents.forEach((d=>{for(let tk in d.tokens){d.tokens[tk]*=idf[tk]}}));const index={documents:documents,idf:idf};storage.set("search-index",index);return index}else{throw new Error("Failed to fetch the index")}}function vectorize(text,idf){const tokens=text.replace(/â€™/g,"'").split(/[^A-Za-z0-9'-]+/).map((t=>t.toLowerCase().replace(/['-]/g,""))).filter((t=>t.length>1));const ngrams=tokens.reduce(((ngrams,tk)=>ngrams.concat(ngram(tk,INDEX_NRGAM_SIZE))),[]).filter((tk=>tk in idf));return countItems(ngrams)}function vectorLength(v){return Math.sqrt(v.reduce(((sum,value)=>sum+value*value),0))}function cosineSimilarity(a,b){const tokens=new Set(Object.keys(a).concat(Object.keys(b)));const product=[...tokens.values()].reduce(((sum,tk)=>sum+(a[tk]||0)*(b[tk]||0)),0);const lenA=vectorLength(Object.values(a));const lenB=vectorLength(Object.values(b));return product/(lenA*lenB)}async function search(query){const index=await getIndex();const idf=index.idf;let results=[];if(query){const vector=vectorize(query,idf);const tfMax=Object.values(vector).reduce(((max,freq)=>freq>max?freq:max),0);for(let tk in vector){vector[tk]=(.5+.5*vector[tk]/tfMax)*idf[tk]}if(Object.values(vector).length>0){results=index.documents.reduce(((res,document)=>{const score=cosineSimilarity(document.tokens,vector);if(score>.1){res.push({title:document.title,date:document.date,url:document.url,score:score})}return res}),[]).sort(((a,b)=>b.score-a.score))}}return results}})();